def hammingdis(p,q):
    count = []
    for i in range(0,len(p)):
        if p[i] == q[i]:
            continue
        else:
            count.append(i)
    return len(count)

def Distance(Pattern,Dna):
    k = len(Pattern)
    reftext = ''
    for tide in Dna:
        if tide == ' ':
            break
        reftext += tide
    n = len(reftext)
    distance = 0
    for i in range(0,len(Dna)-n+1,n+1):
        d = k + 1
        for t in range(i,i+n-k+1):
            if hammingdis(Pattern,Dna[t:t+k]) < d:
                d = hammingdis(Pattern,Dna[t:t+k])
        distance += d
    return distance

# Pattern = 'GCGACA'
# Dna = '''TCCCGTTCGACCGATTGCCCCGTGCATTACCGTGGAAAGAAATCAACCCATTTTTATGGAAATTATGCTGTGCTGGAAACATAATTAATGTCAACGATCT GACTCGTAGTAGTTGGGACGGTGGTTGGCCTGAAGGCCCTTGCGCTGACCATAGTCATCCGAGAAATGTTACCCGAGTGCCGGCTTTGAAAACGCGCTTC ACACTGGCCCGAGAATGGACAACGTCATTACTGCTGCGCCTTATCCATCTGTACGCGAAGGTGATATTGACACCGTTAAATAACTCAGCTCAGCAGTAAG GATATGCGCAAGTCCTGGGTGTAGTAATATCGACTCGGTTGATACGCACTGCGAGGACTCTAGAAAGCTCACCATGTCCTCGGGCGCAGCCTTTCCTTTA CTCTGTAGATCGAAGAGTGGGGGCGAACTGGCTTACTCGGAGTGACATGAACCGCGACGGATATTTTCACTATAACTCAGTCTCCCTATAAGGGGGATTA ACAGGTTCGCTGGCCATTACAACCCAGTCGAGACAGTAATTTGCTTCCTGTCGTTTGGTTAACCGGATAGGCAACCGGTGGCACCTGGTCGAGCCCGGTA AGCGTGGCTACCGGCTGTCCGAGATACGCGTCTGGAACATCTGGCAGGTCCAGCTTAGGACGGCCCTATACACGGAGCACTCGACCCCATCTACGATGTC TTGTAGTGGCTACGGGACCATTTCCCGAAACGCGGTGTCAGCAACGTCCCACCTATCACACCTAGGCGGCTTACCTAGTCAACACCCATGGTAGTCGTGT GGGGGGGACCCTTAAGGTATAATGACACGTGTACTACACCTGTTTCCCACTGAGCAGTAGCATTCTTTCCATTATTAACGAGGAATTTATTCGGAACCAC GGAAGTTAGCTTGTATTAGCTTATCCCGGATGTGCAGCAGGCTTAATTCCGACATGTAGGACACACCGAGTTGTCGTTGTGGCCGGGAACTGACGCTCCG CACAGCACACGTGGATTACAATTCGCTCTCGTACTCCGCACACTCGACGGATCGTGCGCGTACGAACATTGTCGGTTCTTAAAGCGAAAGTAACGATAGT GTACTTGTGCCTATCCGTTTTGTAGGGGTACGATGAAACCGGTCCCCGACATGGCCCACCACGTTTATGGTTTAATGCAGATGCAGATCCGACCACTTGG AGAAGACCGAAGAGAATCGTCGCTACCCACTCCAGACGTCCTACAAAATCGCTATCTGAGGCGCTCAACCTGGCACATCGTGACCATGTTGGCAACGCTC GGACCTTAGGCCGATGATTCTCTCAGAGCGGGTTGACCAACTGCACCCACCTAGTATATCCGTACGTTTACGTCTGACTAATAAAAAGTGACGCCACCAT GAGTTCTTAACAAGTGGCACAACCATCAATCGGTAAAGGTGCGCGCAAAATAAGAACCGGGATGAGGGTGTGGGTATGCTGGGCTTGTTTCACATTGTGT GAGGTCTAGCCTGACCTCCGATTCCATCGATACTCAGCGTGAACGGCTTGACAGTCAACTATGATTCGCTGACCACACCACGAAAGAATCAAACGAAGTA GGACCTAATGAAACAGAGAAAGCTCACCGGATCACGAAAGAGCATCTATCCCATATCTTGTGCAACATAATCACTTTTACCTTCTTTAATTGGCTAAAAA AACGCCACTCATACTAGCGCTACCAGAGCTGCAATGTAAGACGGCGTCGCGGTCAGACTACGTTCCCCCCGGGGAATTACGATTGACGACGCCCTGTGTC CACTCTTACTACTACAGGCTGACTTGGCCTGAAGCAACCCTCCGTTGCTTGCTTGTGAGTCTATTCGTGGAAGGGTGAGAGTACTTGTGATAGACTATGA CCCGAAAGTAGGCTGCTTACATCTATTACCTAATGACGATGCACGATCTTTCTACTACCTTGATGCCAGAAGTCTGTAGAGATTTTGAGGGACTAAACGC TTAAAACTACTAGCACGGCGCACCTCGCGCACTTTAAATGGTGGCATGGTGAGGGCGCTGACGGCTGGAACTTTTGTGGCGGTGTAGTCAATGGGAGCGC CGGCCGTCCTATTTGGTGCAATGAAGACCCCCGTCAACTCCCTCGCTGCACGGCGGCCCGTTTGGGGCTCTGATCACTGGCGGAGCATTCTAGATAGTAA GTAGGCTCTACCCTTGGGAGAGCAATTGACGGAGGGACTTGCCCGAGGCTGGTAAAGACCGCTATGTAGGTTTGAAATCGGAAGTTGATGGTCGGCCAAA AAAACTAGCAGTAGGACGGACTCAGATCAACAGTTCAAGACCCGGCCCAATATATGAGAGGAGATACTGAGTTCACACCGCGGCTCAGGGGCGGTGCTGT AACCTCCAGGGAGTATATTACTATTGTACGCCGGTACATCAGTCCCCCTTGGCTGGCCATCAGGGTGATGAAACTCCGATCTTGTTGATCCGGGCCTCCC GAGAGAGGGGTAAAAGCCGCTTTGATAGGCTGCTATTGCCCGTGACACGGGGGGGCTGGTTTGGTAGATAACCACTGAACTGAATAATCCCTAATAAGCA CAAACAATCGACGGGTCTACCCACATAACTGAACTGGCTGCTATGGGCAAGATCTCTATTCGACGATACAATAGTCATGAGGCGGCCAATAGCGATGCCG ACAACCATCACGAAAGACTGGGAGACTGGTCCGTTCTGACTTTATCACTAACAGCAGAGCGAGATATGTTTTCGCAAATCTAAGCGACTCCTTGCCCCGT TTGACTTAAACGAAGAAGAAAAAACGGCGGACGTGTAGACAAAGACTTGTTGCTCCGGAGTCTTACGAGCCCTGTACGCCGGGGGCTATCATATTATCTT TTACTCGAGCCGCAACAAAGTTGATAACCGCTCGTCGGTCTCGATAGGGGTGACGGAACATTGCCCCTACGGTGTGTAGGCCCTTTATTGCCAACTAGAA CCCCGGCCCATGGCGCACGCGTTTCCATAAGATGCACGCCCAACCGATTAAAACGCGACTCACCCCGTAGCAGACTGACTACCTCTCTGTTACTTCTCGT'''
#
# print(Distance(Pattern,Dna))

def neighbors(pattern,d):
    if d == 0:
        return pattern
    elif len(pattern) == 1:
        return ['A','C','T','G']
    else:
        neighborhood = []
        suffixneighbors = neighbors(pattern[1:],d)
        for text in suffixneighbors:
            if hammingdis(pattern[1:],text) < d:
                for x in ['A','T','C','G']:
                    neighborhood.append(x + text)
            else:
                neighborhood.append(pattern[0] + text)
    return neighborhood

def MedianString(k,Dna):
    # pattern = 'A'
    # for i in range(0,k-1):
    #     pattern += 'A'
    neighborhood = []
    reftext = ''
    for tide in Dna:
        if tide == ' ':
            break
        reftext += tide
    n = len(reftext)
    for i in range(0,len(Dna)-n+1,n+1):
        for t in range(i,i+n-k+1):
            neighborhood.append(Dna[t:t+k])
    distance = float('inf')
    for kmer in neighborhood:
        if Distance(kmer,Dna) < distance:
            distance = Distance(kmer,Dna)
            result = kmer
    return result


k = 7
Dna = '''CTCGATGAGTAGGAAAGTAGTTTCACTGGGCGAACCACCCCGGCGCTAATCCTAGTGCCC GCAATCCTACCCGAGGCCACATATCAGTAGGAACTAGAACCACCACGGGTGGCTAGTTTC GGTGTTGAACCACGGGGTTAGTTTCATCTATTGTAGGAATCGGCTTCAAATCCTACACAG'''
print(MedianString(k,Dna))
